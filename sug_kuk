
.include "m328pdef.inc"

.def led_reg = r16
.def temperature_reg = r17
.def loop_reg_1 = r18
.def loop_reg_2 = r19
.def temp_reg = r20
.def temporary = r21


.equ EOS = 0

.cseg

	rjmp reset

reset:
	
	rcall SPI_master_init

	//Function Set
	cbi PORTB, 1
	cbi PORTB, 2
	ldi led_reg, 0x39
	rcall spi_txrx 
	rcall delay_30ms

	//Bias Set
	ldi led_reg, 0x1D
	rcall spi_txrx 
	rcall delay_30ms

	//Power Control
	ldi led_reg, 0x50
	rcall spi_txrx 
	rcall delay_30ms

	//Follower Control
	ldi led_reg, 0x6C
	rcall spi_txrx 
	rcall delay_30ms

	//Contrast Set
	ldi led_reg, 0x7C
	rcall spi_txrx 
	rcall delay_30ms

	//Function Setc
	ldi led_reg, 0x38
	rcall spi_txrx 
	rcall delay_30ms

	//Display ON/OFF
	ldi led_reg, 0x0F
	rcall spi_txrx 
	rcall delay_30ms

	//Clear Display
	ldi led_reg, 0x01
	rcall spi_txrx 
	rcall delay_30ms

	//Entry Mode Set
	ldi led_reg, 0x06
	rcall spi_txrx 
	rcall delay_30ms
	sbi PORTB, 2 
	sbi PORTB, 1

main_loop:
	
	rcall read_sensor
	;rcall number_to_display
;	ldi r16, 0x07 
;	rcall set_cursor ; flyttar cursorn till den pos 7 på första raden
	rcall update_LCD 
	rcall write
	
	rjmp main_loop

update_LCD:
	;Börjar med att reservera utrymme i SRAM för bytsen med hjälp av Z pekaren 
	;Ladda 
	
	ldi ZL, low(Temp*2)
	ldi ZH, high(Temp*2)
	ldi XL, low(Temp_res)
	ldi	XH, high(Temp_res)
	rcall write
	
	ldi ZL, low(degrees*2)
	ldi	ZH, high(degrees*2)
	ldi XL, low(degrees_res)
	ldi	XH, high(degrees_res)
	rcall write
	;/*
	ldi ZL, low(lim*2)
	ldi	ZH, high(lim*2)
	ldi XL, low(lim_res)
	ldi	XH, high(lim_res)
	rcall write

	ldi ZL, low(degree_lim*2)
	ldi	ZH, high(degree_lim*2)
	ldi XL, low(degree_lim_res)
	ldi	XH, high(degree_lim_res)
	rcall write

	ldi ZL, low(larma*2)
	ldi	ZH, high(larma*2)
	ldi XL, low(larma_res)
	ldi	XH, high(larma_res)
	rcall write

	ldi ZL, low(larm_variabel*2)
	ldi	ZH, high(larm_variabel*2)
	ldi XL, low(larm_variabel_res)
	ldi	XH, high(larm_variabel_res)
	rcall write
	;*/
	ret
	

read_sensor:
	
	sbi PORTB, 6
	clr r16
	cbi PORTB, 6
	rcall spi_txrx ;samlar in datat som ligger på SPI:n och lägger över på temperatur registret
	rcall delay_mega
	mov r24, led_reg
	lsl r24
	rcall spi_txrx
	mov r18, led_reg
	lsl r18
	ROL r18
	andi r18, 0b00000001
	OR r24, r18 ;r16 och r18 adderas ihop och värdet sparas på r16
	sbi PORTB, 6
	ret

number_to_display:
	
	ldi r25, 0x00
	inc r25 
	subi r24, 10 
	cpi r24, 0x00000001
	rjmp number_to_display
	inc r25
	dec r24
	cpi r24, 0x00000000
	subi r24, -48
	subi r25, -48
	ret

;set_cursor:
	
;	rcall spi_txrx 
;	rcall delay_30ms
;	ret

write:
	clr led_reg
	sbi PORTB, 1  ;RS
	rcall delay_mega
	lpm led_reg, Z+ 
	st x+, led_reg
	tst led_reg
	breq bye
	cbi PORTB, 2  ;SS
	rcall delay_mega
	rcall spi_txrx
	sbi PORTB, 2 
	rjmp write
	rjmp bye

bye:
	ret

SPI_master_init:
	clr r16 
	;SS, MOSI, SCK pins sätts till outputs
	ldi r16, (1<<2) | (1<<3) | (1<<5)
	out DDRB, led_reg
	;starta SPE, sätt som master, sätt clock rate till fck/16
	ldi r16, (1<<SPE) | (1<<MSTR) | (1<<SPR0)
	out SPCR, r16
	; done
	ret

spi_txrx:
	out SPDR, led_reg ; start tx/rx cycle by writing to SPDR
wait_txrx:
	in led_reg, SPSR  ; read status register
	sbrs led_reg, SPIF  ; skip if bit transfer complete
	rjmp wait_txrx
	in led_reg, SPDR  ; transfer complete, save received data
	ret 

delay_mega:
	ldi loop_reg_2, 255
loop_3:
	ldi loop_reg_1, 255
	dec loop_reg_2
	tst loop_reg_2
	brne loop_2 
	ret
loop_4:
	dec loop_reg_1
	tst loop_reg_1
	breq loop_3
	rjmp loop_4

delay_30ms:
	ldi loop_reg_2, 25
loop:
	ldi loop_reg_1, 255
	dec loop_reg_2
	tst loop_reg_2
	brne loop_2 
	ret
loop_2:
	dec loop_reg_1
	tst loop_reg_1
	breq loop
	rjmp loop_2

//Minnnesdetaljer

;Flashminnet:
.cseg
temp: .db"Temp",EOS
degrees: .db"     XX°C   ",EOS
lim: .db "Lim", EOS
degree_lim: .db " XX°C to XX°C", EOS
larma: .db "Larm", EOS
larm_variabel: .db " X          ", EOS ;W, C, P motsvarar Warm, Cold, Perfect

;SRAM minnet: 
.dseg 
.org SRAM_START

;Första raden:
temp_res: .byte 5
degrees_res: .byte 11

;/*
;Andra raden:
lim_res: .byte 3
degree_lim_res: .byte 13

;Tredje raden: 
larma_res: .byte 4
larm_variabel_res: .byte 12
;*/
